# アシスタント開発ルール

## 1. 基本方針
私（AIアシスタント）は、このプロジェクトにおいて、CLAUDE.mdの「System Construction Flow」セクションに定義されたプロセスを厳格に遵守して開発を支援します。

## 2. 遵守するプロセス
**注：詳細なシステム構築フローはCLAUDE.mdの「System Construction Flow」セクションを参照**

開発プロセスの重要ポイント：
- 全体設計は常に `design.md` を参照
- フェーズ詳細設計は `/doc/designs/phase-N/` に作成
- Issue定義は `/doc/issues/phase-N/` に作成
- テンプレートを必ず使用

## 3. プロセスからの逸脱について
もし私がこのプロセスから逸脱した提案をした場合は、その提案を拒否し、このドキュメント (`doc/assistant_development_rules.md`) を参照してプロセスに従うよう再度指示してください。

## 4. 自動化と手動検証のハイブリッドアプローチ

AIや自動化ツールの提案は、開発を加速させるための「仮説」として扱います。特に、**新しいライブラリの導入や、既存ライブラリのメジャーバージョンアップが関わる場合**は、以下の「検証ステップ」を必ず実行し、その結果をユーザーに報告します。

### 4.1 検証ステップ

1.  **公式ドキュメントの相互参照**:
    *   AI（私）は、提案を行う前に、関連する技術（例: SvelteKit, Tailwind CSS）の**最新の公式ドキュメント**（インストールガイド、マイグレーションガイド等）をWeb検索等で確認し、提案内容が現在のベストプラクティスと一致しているかを検証します。

2.  **サンドボックス環境での最小構成テスト**:
    *   もし、公式ドキュメントとツールの挙動に乖離が見られる、あるいは問題が解決しない場合、**「サンドボックス検証」**を提案します。
    *   これは、現在のプロジェクトから一旦離れ、`pnpm create`のようなコマンドで最小限のクリーンな環境を新規に作成し、そこで問題の機能（例: Tailwind CSSのセットアップ）が単体で正しく動作するかをテストするプロセスです。
    *   このテスト結果をもって、問題が「我々のプロジェクト固有の設定」にあるのか、「ライブラリやツール自体の問題」なのかを正確に切り分けます。

3.  **「なぜ」の報告義務**:
    *   問題が発生し、その解決策を提案する際には、コードの変更内容（What）だけでなく、**「なぜその問題が起きたのか（Why）」**と**「なぜこの解決策が有効なのか（Why）」**を、構造的に分析し、ユーザーに説明する義務を負います。これにより、場当たり的な修正を防ぎ、プロジェクト全体の技術的負債を低減させます。

### 4.2 仮説検証サイクルと状態確認 (Hypothesis-Verification Cycle and State Confirmation)

#### **ルール: 「全ての操作は『仮説』である。仮説は、その結果を観測することによってのみ『事実』となる」**

私（AIアシスタント）が行う全ての操作（コード生成、コマンド実行、ファイル編集）は、「これを実行すれば、システムは期待する状態に遷移するはずだ」という**仮説**の提示に他ならない。この仮説を検証せず、次の仮説を積み重ねることは、不確実性の上にさらに不確実性を築く行為であり、技術的負債の源泉となる。

#### プロセス (Process)

したがって、全ての状態変更操作において、私は以下の仮説検証サイクルを遵守する義務を負う。

1.  **仮説の提示 (Operation)**: 「Xという操作をすれば、Yという状態になるはずだ」という仮説を立て、操作を実行する。

2.  **結果の観測 (Observation)**: 操作の終了メッセージ（例: exit code 0）を信頼するのではなく、**Yという状態が実際に実現されているか**を直接的な方法（例: ファイルの中身を読む、APIを叩く、クエリを実行する）で観測・測定する。

3.  **考察 (Reflection)**:
    -   観測結果が仮説と一致した場合、その状態は「検証済みの事実」となり、次のステップに進むことができる。
    -   観測結果が仮説と一致しなかった場合、**「なぜ仮説は間違っていたのか」**という新たな問いを立て、原因が特定できるまでデバッグと仮説検証のサイクルを繰り返す。根本原因の分析を伴わない安易な再試行は、この考察の放棄であり、原則として禁止する。

### 4.3 作業ディレクトリの意識と絶対パスの使用 (Directory Context and Absolute Path Usage)

#### ルール: 「全てのファイル操作は、意図した絶対パスに対して実行されなければならない」

相対パスによるファイル操作や、作業ディレクトリへの依存は、予期せぬコンテキストエラーの温床となる。特に、複数のプロジェクト（サンドボックス環境など）を同時に扱う場合、作業ディレクトリの誤認はプロジェクト構造を破壊する致命的なミスに繋がる。これを防ぐため、ファイル操作は常に絶対パスで行うことを原則とする。

#### プロセス (Process)

したがって、ファイルシステムの読み書きや変更を行う全てのツール（`edit_file`, `read_file`, `delete_file`, `run_terminal_cmd`など）を使用する際、私は以下のプロセスを遵守する義務を負う。

1.  **絶対パスの強制 (Absolute Path Mandate)**:
    *   全てのファイルパス指定において、**常に絶対パスを使用する。** これには、各種ツール（`edit_file`など）の `target_file` パラメータや、ターミナルコマンド内のファイル指定が含まれる。
    *   これにより、現在の作業ディレクトリの状態に関わらず、操作の対象が一意に定まることを保証する。

2.  **CWDと操作対象の明示 (Declare CWD and Target)**:
    *   ターミナルコマンドの実行を提案する際、その説明文の中に「**現在の作業ディレクトリは `[カレントディレクトリの絶対パス]` です。**」と「**`[操作対象の絶対パス]` に対して `[操作]` を行います。**」という2つの情報を必ず含める。
    *   ファイル編集など、ターミナル以外のツールを使用する場合も、「**`[操作対象の絶対パス]` を編集します。**」のように対象を明確に宣言する。

3.  **自己不信と確認 (Self-Distrust and Verification)**:
    *   自身のカレントディレクトリやファイル配置に関する認識を過信しない。
    *   特に重要なファイル操作の前には、必要に応じて `ls -F [絶対パス]` のようなコマンドで、操作対象の親ディレクトリの状態を確認し、自身の前提が正しいかを検証する。

これにより、ユーザーは私の意図を正確に把握し、もし私のコンテキスト認識に誤りがあった場合、操作が実行される前にそれを指摘することが可能となる。 